/*
 * Funambol is a mobile platform developed by Funambol, Inc.
 * Copyright (C) 2003 - 2007 Funambol, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License version 3 as published by
 * the Free Software Foundation with the addition of the following permission
 * added to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED
 * WORK IN WHICH THE COPYRIGHT IS OWNED BY FUNAMBOL, FUNAMBOL DISCLAIMS THE
 * WARRANTY OF NON INFRINGEMENT  OF THIRD PARTY RIGHTS.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA.
 *
 * You can contact Funambol, Inc. headquarters at 643 Bair Island Road, Suite
 * 305, Redwood City, CA 94063, USA, or at email address info@funambol.com.
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Public License version 3.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public License
 * version 3, these Appropriate Legal Notices must retain the display of the
 * "Powered by Funambol" logo. If the display of the logo is not reasonably
 * feasible for technical reasons, the Appropriate Legal Notices must display
 * the words "Powered by Funambol".
 */

package com.funambol.mail;

import com.funambol.util.StringUtil;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Date;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;

import com.funambol.storage.RmsRecordItem;
import com.funambol.storage.ComplexSerializer;
import com.funambol.util.Log;

/**
 * This class models a MIME-style email message. <p>
 *
 * <code>Message</code> extends the <code>Part</code> abstract class, and
 * contains a set of attributes and a 'content'. Messages within a folder also
 * have a set of flags that describe its state within the folder. This state is
 * in turn described by the calss MessageFlags. <p>
 *
 * <code>Message</code> defines some new attributes in addition to those
 * defined in <code>Part</code>. These attributes specify meta-data for the
 * message -i.e., addressing and descriptive information about the message. <p>
 *
 * Clients create new MIME-style messages building an empty <code>Message</code>
 * object and then filling it with appropriate attributes and content.
 * <code>Message</code> objects can be obtained from a <code>Folder</code>
 * too. <p>
 *
 * A <code>Message</code> can be kept completely in memory or loaded from its
 * store when needed. This allows clients to trade memory for performance.
 * Headers and content can be lazy. When they are they get flushed every time
 * the message is stored in a store. When they are needed they are loaded/used
 * and discarded. If they are not lazy then they are always kept in memory.
 * Besides this mechanism for lazy loading, there's also a mechanism for caching
 * which is used to alleviate the slowness of lazy loading. If headers are lazy,
 * then part of them (FROM, TO, SUBJECT and so on) can be cached. Every time
 * they are read from the store they go in cache and kept for further uses. We
 * do not cache the entire headers, but rather only a subset.
 * <p>
 *
 */
public class Message extends Part implements RmsRecordItem {

    // -------------------------------------------------------------- Constants

    public static final char MESSAGE_ITEM_PREFIX = 'M';

    /** TO header name */
    public static final String TO = "To";

    /** FROM header name */
    public static final String FROM = "From";

    /** CC header name */
    public static final String CC = "Cc";

    /** BCC header name */
    public static final String BCC = "Bcc";

    /** REPLY-TO header name */
    public static final String REPLYTO = "Reply-To";

    /** SUBJECT header name */
    public static final String SUBJECT = "Subject";

    // ------------------------------------------------------------- Attributes

    /**
     * The unique ID of this message.
     *
     * This is a string containing the global-unique message ID. It is
     * generated by the application for outgoing messages and is taken from the
     * received message otherewise.
     * By the standard definition this field should be present and unique, but
     * there are buggy servers/clients that do not define it or define it as not
     * unique.
     * It is also important to notice that this is an email message id. Being
     * unique means there is just an email with this id, but we could have more
     * than one message on the client with this id. Suppose for example we have
     * 2 email accounts: A and B and B is just a forward to A. If an email
     * message is sent to A and B, the client will get two messages with the
     * same ID.
     * This means that in practice if a key is needed for a Message, it is
     * better to avoid using the msgid. (@see key field)
     */
    protected String msgid;

    /**
     * A combination of status flags for this <code>Message</code> within a
     * folder, e.g. 'read', 'forwarded', 'draft' etc.
     */
    protected MessageFlags flags;

    /**
     * A Folder can contain many Messages, and each Message has a reference to
     * its Folder
     *
     */
    protected Folder parent;

    /**
     * The sent date of this message
     */
    protected long sent;

    /**
     * The received date of this message
     */
    protected long received;

    /**
     * The content of this Message as an Object (it can be a Multipart or a
     * String)
     *
     * When it is a String, it is stored in the native encoding of the
     * application, regardless of how it has been transferred. During parsing
     * operation, the String is decoded according to the
     * 'Content-Transfer-Encoding' field.
     */
    protected Object content;

    /**
     * Message key. This key is used by the client to identify its messages. The
     * information is not generated by the API and when a Message is created it
     * is left empty (null). It is up to the client to set the key properly.
     * This allows the client to have maximum freedom on how the key is
     * generated (it is even possible for a client to avoid defining a key if
     * not needed).
     */
    protected String key;

    /** This field represents the record id, which is a logical location in the
     * store. This information is managed completely by the API and the client
     * cannot modify or rely on it. For some Store this information may make no
     * sense and could be left empty.
     */
    private int recordId;

    /** Cached "from" address. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private Address from;

    /** Cached "to" address. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private Address to[];

    /** Cached "cc" address. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private Address cc[];

    /** Cached "bcc" address. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private Address bcc[];

    /** Cached "reply to" address. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private Address replyTo[];

    /** Cached subject. Once this information is read for the first time,
     * its value is cached and kept available till the headers are rewritten  */
    private String subject;

    // These contants specify the behavior of the messages. Message can be
    // configured to trade memory for speed. A lazy behavior decreses memory
    // consumption, while caching increases it (opposite effect on speed)

    /** Do not be lazy */
    public static final int NO_LAZY        = 0;
    /** Lazy content. The content is loaded only when needed */
    public static final int LAZY_CONTENT   = 1;
    /** Lazy headers. Headers are loaded only when needed */
    public static final int LAZY_HEADERS   = 128;
    /** Cached "to" addresses. Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_TO       = 2;
    /** Cached "cc" addresses. Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_CC       = 4;
    /** Cached "bcc" addresses. Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_BCC      = 8;
    /** Cached "from" addresses. Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_FROM     = 16;
    /** Cached "subject". Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_SUBJECT  = 32;
    /** Cached "reply to" addresses. Even if headers are lazy, this value can be
     * cached (read through cache) */
    public static final int CACHE_REPLYTO  = 64;

    public int composedMessageLength = -1;


    /** Default value for message behavior. Messages have lazy content and
     * headers, but they cache subject and from. This default is used for each
     * new message */
    private static int globalLaziness      = LAZY_CONTENT | LAZY_HEADERS | CACHE_SUBJECT | CACHE_FROM;

    /** Message behavior. This can overwrite the default value (@see globalLaziness)
     * allowing a message granularity */
    private int laziness;

    /**
     * Randomizer used to generate message unique IDs
     */
    private Random rand = new Random();


    // ----------------------------------------------------------- Constructors

    /**
     * The default constructor <p>
     *
     * Initialize the message with default values suitable for sending it
     * (content-type: text/plain, sent and received date equal to current time).
     * The caller must override these values with the desired content.
     */
    public Message() {
        super(); // init Part

        msgid = createUniqueMessageIDValue();
        flags = new MessageFlags();
        parent = null;
        Date sentDate = new Date();
        sent = sentDate.getTime();
        received = sent;
        content = null;
        key = null;
        recordId = -1;

        from = null;
        to   = null;
        cc   = null;
        bcc  = null;
        replyTo = null;
        subject = null;

        laziness = globalLaziness;
    }

    // --------------------------------------------------------- Static methods

    /** Set the default value for laziness behavior. This value will be applied
     * to any newly created message (existing ones are left unchanged).
     *
     * @param value is a bitmask obtained using LAZY and CACHE constants
     */
    public static void setGlobalLaziness(int value) {
        if (value == NO_LAZY) {
            globalLaziness = NO_LAZY;
        } else {
            globalLaziness |= value;
        }
    }

    /**
     * @return global laziness value
     */
    public int getGlobalLaziness() {
        return globalLaziness;
    }


    // --------------------------------------------------------- Public Methods

    /** Set this message laziness behavior. This value is for this message only.
     *
     * @param value is a bitmask obtained using LAZY and CACHE constants
     */
    public void setLaziness(int value) {
        if (value == NO_LAZY) {
            laziness = NO_LAZY;
        } else {
            laziness |= value;
        }
    }


    /**
     * @return laziness value
     */
    public int getLaziness() {
        return laziness;
    }


    /**
     * This method forces a method to be fetched from the store and brought into
     * memory. The message is entirely loaded, regardless of the laziness
     * settings. For the method to be really reloaded it must belong to an
     * existing and available folder.
     *
     * @throws MailException if the message cannot be re-read from the store.
     */
    public void reloadMessage() throws MailException {
        int origLaziness = laziness;
        laziness = NO_LAZY;
        if (parent != null) {
            try {
                Store store = StoreFactory.getStore();
                DataInputStream is = store.readChildBytes(getParent().getFullName(), 
                        Integer.toString(getRecordId()));
                deserialize(is);
            } catch (IOException ex) {
                throw (new MailException(
                        MailException.STORAGE_ERROR,
                        "Cannot reload message" + key));
            }
        }
        laziness = origLaziness;
    }

    /**
     * Add the specified recipients to the correct header, based on the Address
     * type.
     *
     * @param list
     *            list of Adresses to add to the recipient header. Null items
     *            are simply ignored.
     */
    public void addRecipients(Address[] list) throws MailException {
        int length = list.length;
        String name = null;

        for (int i = 0; i < length; i++) {
            if(list[i] != null) {
                name = typeToName(list[i].getType());
                if (name != null) {
                    addRecipient(name, list[i].toString());
                }
            }
        }
    }

    /**
     * Add the specified recipient to the correct header, based on the Address
     * type (see com.funambol.mail.Address for the defined types).
     *
     * @param address
     *            the address to add to the recipient header. If it is null then
     *            it is simply ignored
     */
    public void addRecipient(Address address) throws MailException {
        if (address != null) {
            String name = typeToName(address.getType());
            if (name != null) {
                addRecipient(name, address.toString());
            }
        }
    }

    /**
     * Allows a client to set the Message key. The key should be unique, but the
     * API does not use this field, therefore it is up to the client to define
     * it in some meaningful way.
     *
     * @param key is the new key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * Get the Message key (maybe null if the client did not set it)
     */
    public String getKey() {
        return key;
    }

    /**
     * Get the sender address. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder). IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the address if it has been defined, null otherwise
     * @throws MailException if the address cannot be parsed
     */
    public Address getFrom() throws MailException {

        Address tmpFrom = null;
        String  tmpFromString = null;
        if (from != null) {
            tmpFrom = from;
        } else if (headers != null) {
            tmpFromString = getHeader(FROM);
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                tmpFromString = (String)tmpHeaders.get(FROM);
            }
        }

        if (!StringUtil.isNullOrEmpty(tmpFromString)) {
            tmpFrom = new Address(Address.FROM, tmpFromString);
        }

        if ((laziness & CACHE_FROM) != 0) {
            // Cache the value
            from = tmpFrom;
        }
        return tmpFrom;
    }


    /**
     * Get the TO addresses. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder).IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the addresses if they have been defined, null otherwise
     * @throws MailException if at least one address cannot be parsed
     */
    public Address[] getTo() throws MailException {

        Address[] tmpTo = null;
        if (to != null) {
            tmpTo = to;
        } else if (headers != null) {
            tmpTo = Address.parse(Address.TO, (String)getHeader(TO));
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                String stringTo = (String)tmpHeaders.get(TO);
                tmpTo = Address.parse(Address.TO, stringTo);
            }
        }

        if ((laziness & CACHE_TO) != 0) {
            to = tmpTo;
        }

        return tmpTo;
    }

    /**
     * Get the CC addresses. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder).IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the addresses if they have been defined, null otherwise
     * @throws MailException if at least one address cannot be parsed
     */
    public Address[] getCc() throws MailException {

        Address[] tmpCc = null;
        if (cc != null) {
            tmpCc = cc;
        } else if (headers != null) {
            tmpCc = Address.parse(Address.CC, (String)getHeader(CC));
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                String stringCc = (String)tmpHeaders.get(CC);
                tmpCc = Address.parse(Address.CC, stringCc);
            }
        }

        if ((laziness & CACHE_CC) != 0) {
            cc = tmpCc;
        }

        return tmpCc;
    }


    /**
     * Get the BCC addresses. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder).IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the addresses if they have been defined, null otherwise
     * @throws MailException if at least one address cannot be parsed
     */
    public Address[] getBcc() throws MailException {

        Address[] tmpBcc = null;
        if (bcc != null) {
            tmpBcc = bcc;
        } else if (headers != null) {
            tmpBcc = Address.parse(Address.BCC, (String)getHeader(BCC));
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                String stringBcc = (String)tmpHeaders.get(BCC);
                tmpBcc = Address.parse(Address.BCC, stringBcc);
            }
        }

        if ((laziness & CACHE_BCC) != 0) {
            bcc = tmpBcc;
        }

        return tmpBcc;
    }


    /**
     * Get the REPLY-TO addresses. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder).
     * If the reply to has not been specified, then "from" is returned.
     * IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the addresses if they have been defined, null otherwise
     * @throws MailException if at least one address cannot be parsed
     */
    public Address[] getReplyTo() throws MailException {

        Address[] tmpReplyTo = null;
        String tmpFrom = "";
        String stringReplyTo = null;

        if (replyTo != null) {
            return replyTo;
        } else if (headers != null) {
            stringReplyTo = getHeader(REPLYTO);
            tmpFrom = getHeader(FROM);
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                stringReplyTo = (String)tmpHeaders.get(REPLYTO);
                tmpFrom = (String)tmpHeaders.get(FROM);
            }
        }

        if (StringUtil.isNullOrEmpty(stringReplyTo)) {
            tmpReplyTo = Address.parse(Address.TO, tmpFrom);
        } else {
            tmpReplyTo = Address.parse(Address.TO, stringReplyTo);
        }

        if ((laziness & CACHE_REPLYTO) != 0) {
            replyTo = tmpReplyTo;
        }

        return tmpReplyTo;
    }


    /**
     * Returns the flag mask for this message.
     *
     * @return the flag mask for this message.
     */
    public MessageFlags getFlags() {
        return flags;
    }


    /**
     * Returns the String representing the ID of this Message.
     *
     * @return The unique ID of this Message
     */
    public String getMessageId() {
        return msgid;
    }


    /**
     * Get the message subject. If the value is in cache then we use that value.
     * Otherwise we check if it is in the headers (in memory). If we cannot find
     * it, then we check if the value is in the store (provided the message
     * belongs to a folder). IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @return the subject if is has been defined, null otherwise
     */
    public String getSubject() {

        String tmpSubject = null;
        if (subject != null) {
            tmpSubject = subject;
        } else if (headers != null) {
            tmpSubject = getHeader(SUBJECT);
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            Hashtable tmpHeaders = getHeaders();
            if (tmpHeaders != null) {
                tmpSubject = (String)tmpHeaders.get(SUBJECT);
            }
        }

        if ((laziness & CACHE_SUBJECT) != 0) {
            subject = tmpSubject;
        }

        return tmpSubject;
    }


    /**
     * Returns the sent date of this message.
     *
     * @return the sent date of this message.
     */
    public Date getSentDate() {
        return new Date(sent);
    }

    /**
     * Returns the sent date of this message as long.
     * the result is the same as getSentDate().getTime(), but this way is faster
     * @return the sent date of this message as long
     */
    public long getSentTime() {
        return sent;
    }




    /**
     * Sets the flag mask for this message.
     *
     * @param flags the flag mask for this message.
     */
    public void setFlags(MessageFlags flags) {
        this.flags.setFlags(flags.getFlags());
    }


    /**
     * Returns the received date of this message.
     *
     * @return the received date of this message.
     */
    public Date getReceivedDate() {
        return new Date(received);
    }


    /**
     * Returns the received date of this message as long.
     * the result is the same as getReceivedDate().getTime(), but this way is
     * faster
     * @return the received date of this message as long
     */
    public long getReceivedTime() {
        return received;
    }

    /**
     * Returns the number of recipients of this email. The number includes
     * addresses in to, cc e bcc.
     *
     * @return the total count
     * @throws MailException if at least one address in the recipients is
     * invalid
     */
    public int getNumberOfRecipients() throws MailException {
        Address[] tmpTo  = getTo();
        Address[] tmpCc  = getCc();
        Address[] tmpBcc = getBcc();
        int toSize  = tmpTo == null ? 0 : tmpTo.length;
        int ccSize  = tmpCc == null ? 0 : tmpCc.length;
        int bccSize = tmpBcc == null ? 0 : tmpBcc.length;
        return toSize + ccSize + bccSize;
    }

    /**
     * This method removes all the recipients of the specified type from this
     * message. IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the implicit call to the private
     * method getHeaders() will fail
     *
     * @param type
     *            one of the defined types in
     *
     */
    public void removeAllRecipients(int type) {
        try {
            String name = typeToName(type);
            if (headers == null) {
                headers = getHeaders();
            }

            if (headers != null) {
                removeHeader(name);
            }
            cleanCachedInfo();
        } catch (MailException me) {
            // Don't propagate exception for remove.
            Log.error(this, "removeAllRecipients() exception raised by " +
                    "typeToname for type " + type);
            me.printStackTrace();
        }
    }

    /**
     * This method sets the content of the RFC 2822 "From:" header with the
     * given <code>Address</code>.
     */
    public void setFrom(Address from) {

        if (headers == null) {
            headers = getHeaders();
        }
        if (from==null) {
            setHeader(FROM, "");
        } else {
            setHeader(FROM, from.toString());
        }
        this.from = null;
    }


    /**
     * Set the content of the RFC 2822 "To:" header with the provided addresses,
     * passed as an Address array
     *
     * @param tolist
     *            list of Adresses to put in the To: list
     */
    public void setTo(Address[] tolist) {

        if (headers == null) {
            headers = getHeaders();
        }
        setRecipients(TO, tolist);
        this.to = null;
    }


    /**
     * Set the content of the RFC 2822 "Cc:" (carbon copy) header with the
     * provided addresses, passed as an Address array
     *
     * @param cclist
     *            list of Adresses to put in the Cc: list
     */
    public void setCc(Address[] cclist) {

        if (headers == null) {
            headers = getHeaders();
        }
        setRecipients(CC, cclist);
        this.cc = null;
    }


    /**
     * Set the content of the RFC 2822 "Bcc:" (blind carbon copy) header with
     * the provided addresses, passed as an Address array
     *
     * @param bcclist
     *            list of Adresses to put in the bcclist
     */
    public void setBcc(Address[] bcclist) {

        if (headers == null) {
            headers = getHeaders();
        }
        setRecipients(BCC, bcclist);
        this.bcc = null;
    }


    /**
     * Set the content of the RFC 2822 "Bcc:" (blind carbon copy) header with
     * the provided addresses, passed as an Address array
     *
     * @param replytolist
     *            list of Adresses to put in the bcclist
     */
    public void setReplyTo(Address[] replytolist) {

        if (headers == null) {
            headers = getHeaders();
        }
        setRecipients(REPLYTO, replytolist);
        replyTo = null;
    }


    /**
     * Set the content of the RFC 2822 "Subject:" header.
     *
     * @param subject
     *            The text to put in the Subject
     */
    public void setSubject(String subject) {

        if (headers == null) {
            headers = getHeaders();
        }
        setHeader(SUBJECT, subject);
        this.subject = null;
    }


    /**
     * Returns this message's parent Folder
     *
     * @return A reference to the Folder object this Message is contained in
     */
    public Folder getParent() {
        return parent;
    }


    /**
     * Sets a reference to the <code>Folder</code> this <code>Message</code>
     * is contained in
     *
     * @param parent
     *            The folder this <code>Message</code> is a child of
     */
    public void setParent(Folder parent) {
        this.parent = parent;
    }


    /**
     * Set the sent date
     *
     * @param sent
     *            the sent date
     */
    public void setSentDate(Date sent) {
        this.sent = sent.getTime();
    }


    /**
     * Set the received date
     *
     * @param received
     *            the received date
     */
    public void setReceivedDate(Date received) {
        this.received = received.getTime();
    }


    /**
     * Get the content of this message: can be a String or a Multipart.
     *
     */
    public Object getContent() {

        Object tmpContent = content;
        if (content == null && parent != null && ((laziness & LAZY_CONTENT) != 0)) {
            // Perform on demand content loading
            Store store = StoreFactory.getStore();
            DataInputStream is = store.readChildBytes(getParent().getFullName(),
                        Integer.toString(getRecordId()));
            // The content can be null if the message got deleted from the store
            // but is still in memory. deserialize throws a null pointer
            // exception is invoked with a null stream.
            if (is != null) {
                tmpContent = deserializeContent(is);
            }
        }
        return tmpContent;
    }


    /**
     * Convenience method to get the body for text messages
     *
     * @return the text content of the message, or null this message has no text
     *         content.
     */
    public String getTextContent() {
        Object cont = getContent();
        if (cont instanceof String) {
            return (String)cont;
        }else if (cont instanceof Multipart){
            BodyPart bp = ((Multipart)cont).getBodyPart(0);
            String text = bp.getTextContent();
            return text;
        }else {
            return null;
        }
    }


    /**
     * Sets the content of this Message. It can be a Multipart or a String. This
     * method sets also the contentType: multipart/mixed if the content is
     * Multipart, text/plain if it's a String
     *
     */
    public void setContent(Object content) throws MailException {
        if (content instanceof Multipart) {
            ((Multipart)content).setContainer(this);
            contentType = "multipart/mixed";
        } else if (content instanceof String) {
            contentType = "text/plain";
        } else {
            throw (new MailException(
                    MailException.INVALID_CONTENT,
                    "Invalid content: " + content.getClass().getName()));
        }

        //see explication in Part.setContentType
        setContentType(contentType);
        this.content = content;
    }

    /**
     * Sets the body text of this Message.
     *
     */
    public void setTextBody(String text){
        if(isMultipart()){
            Multipart multipartContent = (Multipart)getContent();
            BodyPart bp = multipartContent.getBodyPart(0);
            multipartContent.removeBodyPart(0);
            bp.setContent(text);
            multipartContent.addBodyPart(bp,0);
            this.setContent(multipartContent);
        }else{
            this.setContent(text);
        }
    }


    /**
     * Sets the content of this Message. This can be another Multipart (in case
     * of a multi-content message) or a String (in case of a 'single-content'
     * message)
     *
     * @param content
     *            The content object
     * @param type
     *            The MIME type of the content
     */
    public void setContent(Object content, String type) throws MailException {
        setContent(content);
        setContentType(type);
    }


    /**
     * Sets the String representing the unique ID of this Message
     */
    public void setMessageId(String messageId) {
        msgid = messageId;
    }

    public boolean hasAttachments(){
        if(isMultipart()){
            Multipart multipartContent = (Multipart)getContent();
            if(multipartContent.getCount() >1){
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }

    }

    public int attachmentsNumber(){
        if(isMultipart()){
            Multipart multipartContent = (Multipart)getContent();
            if(multipartContent.getCount() >1){
                return (multipartContent.getCount() -1);
            }else{
                return 0;
            }
        }else{
            return 0;
        }
    }


    // -------------------------------------------- RmsRecordItem implementation

    /**
     * @see com.funambol.storage.Serializable#serialize(java.io.DataOutputStream)
     */
    public void serialize(DataOutputStream dout) throws IOException, MailException {

        writeRecordPrefix(dout);

        if (content == null) {
            content = getContent();
        }

        if (headers == null) {
            // We may have some information cached
            headers = getHeaders();
        }

        dout.writeUTF(msgid);
        flags.serialize(dout);

        // Parent must be set by Folder when the message is retrieved,
        // so it's not saved.

        // key must be set by MessageManager when the message is retrieved,
        // so it's not saved.

        // Write Part attributes
        ComplexSerializer.serializeHashTable(dout, headers);
        dout.writeUTF(contentType);

        dout.writeLong(sent);
        dout.writeLong(received);

        ComplexSerializer.serializeObject(dout, content);
        if ((laziness & LAZY_CONTENT) != 0) {
            content = null;
        }
        if ((laziness & LAZY_HEADERS) != 0) {
            headers = null;
        }
        dout.writeInt(composedMessageLength);
    }

    /**
     * @see com.funambol.storage.Serializable#deserialize(java.io.DataInputStream)
     */
    public void deserialize(DataInputStream din) throws IOException {

        // Deserialize everything but keep in memory only what is not lazy
        msgid = din.readUTF();

        // Deserialize flags
        flags.deserialize(din);

        Hashtable tmpHeaders = ComplexSerializer.deserializeHashTable(din);
        if ((laziness & LAZY_HEADERS) == 0) {
            headers = tmpHeaders;
        }

        String contentType = din.readUTF();       // contentType.length
        this.setContentType(contentType);
        sent = din.readLong();     // 8 bytes
        received = din.readLong(); // 8 bytes

        if ((laziness & LAZY_CONTENT) == 0) {
            content = ComplexSerializer.deserializeObject(din);

            // Set the container reference for Multipart
            if (content instanceof Multipart) {
                ((Multipart)content).setContainer(this);
            }

            try{
                composedMessageLength = din.readInt();
            }catch(Exception ex){
                // This is an old message
            }
        }
    }

    /**
     * @see com.funambol.storage.RmsRecordItem#setRecordId(int)
     */
    public void setRecordId(int id) {
        recordId = id;
    }

    /**
     * @see com.funambol.storage.RmsRecordItem#getRecordId()
     */
    public int getRecordId() {
        return recordId;
    }

    private Object deserializeContent(DataInputStream din) {

        // When we load only the content we should skip all the headers and
        // start deserializing the content. But we do not know the size of the
        // headers, so we read them and in case they are not needed we just
        // discard them.

        try {
            String tempString = din.readUTF();
            MessageFlags tempFlags = new MessageFlags();
            tempFlags.deserialize(din);
            Hashtable tmpHeaders = ComplexSerializer.deserializeHashTable(din);
            tempString = din.readUTF();       // contentType.length
            this.setContentType(tempString);
            din.readLong();     // 8 bytes
            din.readLong(); // 8 bytes

            Object cont = ComplexSerializer.deserializeObject(din);

            // Set the container reference for Multipart
            if (cont instanceof Multipart) {
                ((Multipart)cont).setContainer(this);
            }

            return cont;
        } catch (IOException ex) {
            // Just ignore this and leave the content empty
            ex.printStackTrace();
            Log.error("[deserializeContent] Cannot load record");
        }

        return null;
    }

    private Hashtable deserializeHeaders(DataInputStream din) {

        // When we load only the headers we should skip all the headers and
        // start deserializing the content. But we do not know the size of the
        // headers, so we read them and in case they are not needed we just
        // discard them.

        try {
            String tempString = din.readUTF();
            MessageFlags tempFlags = new MessageFlags();
            tempFlags.deserialize(din);
            Hashtable tmpHeaders = ComplexSerializer.deserializeHashTable(din);
            return tmpHeaders;
        } catch (IOException ex) {
            // Just ignore this and leave the content empty
            ex.printStackTrace();
            Log.error("[deserializeContent] Cannot load record");
        }

        return null;
    }

    public int getComposedMessageLength() {
        // This property is stored after the content, so we need to load
        // everything before we can access it
        try{
            if (composedMessageLength == -1 && parent != null && ((laziness & LAZY_CONTENT) != 0)) {
                // Perform on demand content loading
                Store store = StoreFactory.getStore();
                DataInputStream is = store.readChildBytes(getParent().getFullName(),
                        Integer.toString(getRecordId()));
                deserializeContent(is);
                composedMessageLength = is.readInt();
            }
            return composedMessageLength;
        }catch(Exception ex){
            // This is an old message
            return -1;
        }
    }

    public void setComposedMessageLength(int length) {
        composedMessageLength = length;
    }

    /**
     * Creates a unique value for use in the Message ID <p>
     *
     * This implementation generates it by concatenating a newly created
     * object's <code>hashCode()</code>, a random long with seed from the the
     * current time, and the string "@Funambol.mail".
     *
     * TODO: usually the message ID ends with the domain name of the host
     * originating the message, or the one of the user's mail address, but this
     * is not easy to do on the phone.
     */
    public String createUniqueMessageIDValue() {
        StringBuffer s = new StringBuffer();

        // Unique string is <timestamp><random>@Funambol.mail
        s.append(System.currentTimeMillis()).append(rand.nextInt()).append(
                "@Funambol.mail");

        return s.toString();
    }

    // -------------------------------------------------------- Private Methods

    /**
     * Converts the address type in a header name
     *
     * @param type the type if the address (see com.funambol.mail.Address )
     * @return the header name
     */
    private String typeToName(int type) throws MailException {
        switch (type) {
            case Address.FROM:
                return Message.FROM;
            case Address.TO:
                return Message.TO;
            case Address.CC:
                return Message.CC;
            case Address.BCC:
                return Message.BCC;
            case Address.REPLYTO:
                return Message.REPLYTO;
            default:
                throw new MailException(
                        MailException.INVALID_ADDRESS,
                        "Invalid address type: "+type);
        }
    }


    /**
     * @param name
     * @param value
     */
    private void addRecipient(String name, String value) {

        if (headers == null) {
            headers = getHeaders();
        }
        String header = getHeader(name);
        if (header != null) {
            if (header.trim().length()!=0) {
                header = new StringBuffer(header).append(", ")
                .append(value).toString();
            } else {
                header = value;
            }
        } else {
            header = value;
        }
        setHeader(name, header);
        cleanCachedInfo();
    }


    /**
     * Set the specified recipient with the provided addresses, passed as an
     * Address array
     *
     * @param recipient
     *            the name of the recipient to set
     * @param list
     *            list of Adresses to put in the bcclist
     */
    private void setRecipients(String recipient, Address[] list) {
        int length = list.length;
        if (length>0) {
            StringBuffer buffer = new StringBuffer(list[0].toString());

            for (int i = 1; i < length; i++) {
                if(list[i] != null && !"".equals(list[i])) {
                    buffer.append(", ").append(list[i].toString());
                }
            }

            if (headers == null) {
                headers = getHeaders();
            }
            setHeader(recipient, buffer.toString());

            // Clean cached information
            cleanCachedInfo();
        }
    }

    /**
     * Get the message raw headers. If the headers are already in memory they
     * are just returned. If they are not in memory and the message has a lazy
     * loading strategy then we try to read them from the Store (provided the
     * message belongs to a folder).
     * IMPORTANT: a parent MUST be set for this message
     * before calling this method, otherwise the method call will fail returning
     * an empty hashtable
     * If headers do not exist, a new instance is created.
     *
     * @return the headers (cannot be null)
     */
    private Hashtable getHeaders() {

        if (headers != null) {
            return headers;
        } else if (parent != null && ((laziness & LAZY_HEADERS) != 0)) {
            // Perform on demand "headers" loading
            Store store = StoreFactory.getStore();
            DataInputStream is = store.readChildBytes(getParent().getFullName(),
                        Integer.toString(getRecordId()));
            headers = deserializeHeaders(is);
        }

        if (headers == null) {
            headers = new Hashtable();
        }
        return headers;
    }

    /**
     * Clean all the cached information.
     */
    private void cleanCachedInfo() {
        to = null;
        from = null;
        cc = null;
        bcc = null;
        replyTo = null;
        subject = null;
    }

    /**
     * Check whether the provided prefix char represents a <code>Message</code>
     * <code>DataInputStream</code>
     *
     * @param prefix The item prefix.
     * @return true If supported.
     */
    public static boolean isSupportedStream(char prefix) {
        return (prefix == Message.MESSAGE_ITEM_PREFIX);
    }

    // Append the prefix for a Message record item
    protected void writeRecordPrefix(DataOutputStream dout) throws IOException {
        dout.writeChar(Message.MESSAGE_ITEM_PREFIX);
    }
}
